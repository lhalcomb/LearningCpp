#include <iostream>
#include <vector>

using namespace std;

//passsing pointers through functions

void swapv(int *initial_num, int *new_number){

  int temp;
  cout << " The address of the first variable is: " << &initial_num << endl;
  cout << " The address of the second variable is: " << &new_number << endl;
  temp = *initial_num;
  cout << " The address of temp pointing to the first variable is: " << &temp << endl;
  *initial_num = *new_number;
  cout << " The address of the first variable is: " << &initial_num << endl;
  *new_number = temp;
  cout << " The address of the second variable is: " << &new_number << endl; 

}

void swapInt(int *initial_num, int *new_number){
  int temp;
  temp = *initial_num;
  *initial_num = *new_number;
  *new_number = temp;
}

void swapUsingArithmetic(int *initial_num, int *new_number){
   std::cout << "Before swap: initial_num = " << *initial_num << ", new_number = " << *new_number << std::endl;
   std::cout << "Addresses: initial_num = " << initial_num << ", new_number = " << new_number << std::endl;

    *initial_num = *initial_num + *new_number; // initial_num = 25 + 15, therefore 40 -> temp_variable
    std::cout << "After adding: initial_num = " << *initial_num << ", new_number = " << *new_number << std::endl;
    std::cout << "Addresses: initial_num = " << &initial_num << ", new_number = " << &new_number << std::endl;

    *new_number = *initial_num - *new_number; //new_number = 40 - 15, therefore 25 -> new_number or the swapped version
    std::cout << "After subtracting new_number: initial_num = " << *initial_num << ", new_number = " << *new_number << std::endl;
    std::cout << "Addresses: initial_num = " << &initial_num << ", new_number = " << &new_number << std::endl;


    *initial_num = *initial_num - *new_number; // initial_num = 40 - 25 -> initial_num = 15
    std::cout << "After subtracting initial_num: initial_num = " << *initial_num << ", new_number = " << *new_number << std::endl;
    std::cout << "Addresses: initial_num = " << &initial_num << ", new_number = " << &new_number << std::endl;
  /* 
  It seems that when first adding them together to get another address, we end up creating a temporary variable. 
  That temporary variable being the number we generated by doing the pointer arithmetic. 
  Interesting. 
  Then we move the new_number -> 15, into the appropriate swapped position, by doing the last operation. 
  How exciting. Machine Code is a lot cooler than high level programming. 
  */
}

void double_data(int *int_ptr){
  *int_ptr *= 2;
}

void display(vector<string> *v){
  
  for (auto str: *v)
  {
    cout << str << " ";
  }
  cout << "\n"; 

}

void display_array(const int *const array, size_t size){
  for (size_t i = 0; i < size; ++i) {
    cout << array[i] << " ";
  } 
  cout << endl;
}

//Returning Pointers from functions

//Finds the max between two integers and returns that max. Utilizes pointers 
int *max(int *int_ptr1, int *int_ptr2)
{
  if (*int_ptr1 > *int_ptr2){
    return int_ptr1;
  }else{
    return int_ptr2;
  }
}


//returning dynamically allocated memory

int *create_array(size_t size, int init_value = 0){
  int *new_storage {nullptr};

  new_storage = new int[size];
  for (size_t i {0}; i < size; ++i){
    //*(new_storage + i) = init_value; 

    //init_value++;
    new_storage[i] = init_value;

    init_value++;
  }
  return new_storage; 

}

void multiply_with_pointer(int *ptr, int multiplier){
    *ptr *= multiplier;
    
}

void reverse_array(int* arr, int size) {
   
    int *beginning = arr; 
    int *end = arr + size - 1;
    
    while (beginning < end){
        int temp = *beginning; 
        *beginning = *end;
        *end = temp; 
        
        beginning++;
        end--;
    }
    
}

void reverse_string(char[] s){

  int n = s.size();
  for (int i = 0; i <= n/2; i++){
    char temp = s[i];
    s[i] = s[n-i-1];
    s[n-i-1] = temp;
  }

}

int main()
{
    int* p;
    char* q;
    /*These are pointers of variable types that point to a certain object in memory just like variables
      Unlike variables, pointers are types that can hold the address of a particular object.
    */

   int num = 123;
   int *num_address = &num; //This points to the existing object in memory denoted as x. We use the address-of operator &, and say that n points to x

   char *anEmptyPointer = nullptr; //This declares a pointer variable of a specified empty spot in memory

   std::cout<< "The value of the dereferenced pointer is: " << *num_address << '\n'; 

   *num_address = num * 2;
   std::cout <<"The value of the dereferenced pointer is now: " << *num_address <<endl;

   int anotherNum = 44;
   int *anotherNum_address;

   string name = "Layden";
   cout << "The variable name holds the string value of: " << name << endl;
   string *name_address = &name;
   cout << "The address of the variable name is: " << name_address << endl;

   //anotherNum_address = &anotherNum;
   //std::cout << "\n " << anotherNum_address <<endl;

   cout << "          " << endl;
   cout << "          " << endl;
   cout << "          " << endl;

   int num1, num2;
   cout << "First Number: ";  cin >> num1;
   cout << "Second Number: "; cin >> num2;
   swapv(&num1, &num2);
   cout << "The size of num1 is: " << sizeof(num1) << " bytes\n "; 
   cout <<"After swapping, first number is : " << num1 <<endl;
   cout << "After  swapping, second number is : " << num2 << endl;

   cout << "          " << endl;
   cout << "          " << endl;
   cout << "          " << endl;

   int score {100}; 
   int *score_ptr = &score;
   cout << "Here is an example of dereferencing: " << endl;
   cout << "The address of score is: " << *score_ptr << endl; 
    cout << "The value of score is: " << score << endl;
   *score_ptr = 200; 
   cout << "The value of score is: " << score << endl;
   cout << "The value of score_ptr is: " << *score_ptr << endl;

  cout << "         " << endl; 
  cout << "         " << endl; 
  cout << "         " << endl; 
  cout << "Example of Swap using pointer arithmetic" << endl;
  std::cout << "Initial addresses: num1 = " << &num1 << ", num2 = " << &num2 << std::endl; 
  swapUsingArithmetic(&num1, &num2);
  std::cout << "Final addresses: num1 = " << &num1 << ", num2 = " << &num2 << std::endl;
  
  int val {10};
  cout << "         " << endl; 
  cout << val << endl;
  double_data(&val);

  cout << val << endl; 
  cout << "         " << endl; 
  cout << "         " << endl; 
  cout << "         " << endl; 
  vector<string> superheros {"Superman", "Batman", "Spiderman"};

  display(&superheros);

  cout << "         " << endl; 
  cout << "         " << endl; 
  cout << "         " << endl; 

  //To call a pointer function, it would look like as follows

  int a{100};
  int b{200};
  int *max_ptr = nullptr;
  max_ptr = max(&a, &b);
  cout << *max_ptr << endl; //200

  //use of the create_array pointer function above
  int *my_array; //will be allocated by the function 

  my_array = create_array(100); // create the array 
 
  display_array(my_array, 10); 

  reverse_array(my_array, 10);
  display_array(my_array, 10); 

  delete [] my_array; //frees the storage


  int ptr_int = 1;
  int multiplier = 3;
  //multiply_with_pointer(*ptr_int, multiplier);
   

  return 0;

} 